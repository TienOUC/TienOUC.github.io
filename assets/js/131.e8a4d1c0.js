(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{654:function(t,v,e){"use strict";e.r(v);var s=e(4),_=Object(s.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"js-性能之惰性载入函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-性能之惰性载入函数"}},[t._v("#")]),t._v(" JS 性能之惰性载入函数")]),t._v(" "),e("h3",{attrs:{id:"一、惰性载入概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、惰性载入概念"}},[t._v("#")]),t._v(" 一、惰性载入概念")]),t._v(" "),e("p",[e("strong",[t._v("惰性载入函数：")]),t._v(" 函数执行时会根据不同的判断分支最终选择合适的方案执行，但这样的分支判断仅会发生一次，后面的其他同类执行都不会再分支判断。提高了 JS 执行效率性能。")]),t._v(" "),e("p",[e("strong",[t._v("简单来说：")]),t._v(" 某功能函数如果需要多个分支判断出一套方案，后续执行都仅需这一套方案就可采用 "),e("code",[t._v("惰性载入")]),t._v(" 设计。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/tienouc/blog-img/202111211514850.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"二、设计思想"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、设计思想"}},[t._v("#")]),t._v(" 二、设计思想")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("定义好的函数，实际上在执行的过程中是就可以被动态修改其定义的。")])]),t._v(" "),e("li",[e("p",[t._v("除首次执行外，被修改的定义的函数后续被调用将使用新的函数定义。")])])]),t._v(" "),e("h3",{attrs:{id:"三、示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、示例"}},[t._v("#")]),t._v(" 三、示例")]),t._v(" "),e("p",[t._v("IE 系浏览器不同程度支持 "),e("code",[t._v("attachEvent")]),t._v(" 或 "),e("code",[t._v("addEventListener")]),t._v("，其他大多数浏览器基本都支持 "),e("code",[t._v("addEventListener")]),t._v(" 的方式。因此在用原生 JS 给 DOM 添加事件的时候，我们封装了一个通用函数 "),e("code",[t._v("addEvent")]),t._v(" 用以暴露统一的接口给 dom 添加事件，"),e("code",[t._v("addEvent")]),t._v("中会对是否存在 "),e("code",[t._v("attachEvent")]),t._v(" 或 "),e("code",[t._v("addEventListener")]),t._v(" 进行判断进而使用各自浏览器支持的事件方法给 DOM 添加事件，然而传统的 if else 判断虽然能实现功能，但当前环境下后续的每次事件添加都会依次执行这些分支判断，显然是没有意义的执行，因为判断一次就够了。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("传统 if else")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/tienouc/blog-img/202111211432498.png",alt:""}})])])]),t._v(" "),e("p",[t._v("上述方法在每次调用时都会执行分支判断。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("惰性载入具体实现")]),t._v(" "),e("blockquote",[e("ol",[e("li",[t._v("在函数被调用时再处理函数")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/tienouc/blog-img/202111211432659.png",alt:""}})]),t._v(" "),e("blockquote",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("在函数声明时就指定适当函数")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/tienouc/blog-img/202111211433642.png",alt:""}})])])]),t._v(" "),e("p",[t._v("惰性载入的两种方法，在函数首次执行时做出分支判断，之后每次调用都不会再做兼容判断。")])])}),[],!1,null,null,null);v.default=_.exports}}]);